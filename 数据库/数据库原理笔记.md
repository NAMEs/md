数据库

[参考博客文章](http://blog.jobbole.com/100349/)



##阵列
![](http://ww2.sinaimg.cn/large/7cc829d3jw1f3drdpqm1oj20cl0apdhp.jpg)

这个二维阵列是带有行与列的表：

- 每个行代表一个主体  
- 列用来描述主体的特征  
- 每个列保存某一种类型对数据（整数、字符串、日期……） 

**如果我们要查找所有在UK工作的人，需要N次**；

##树

###二叉查找树
是带有特殊属性的二叉树，每个节点的关键字必须：

- *比保存在左子树的任何键值都要大*
- *比保存在右子树的任何键值都要小*

![](http://jbcdn2.b0.upaiyun.com/2016/05/432222c9e8cd2d665083915430ae1a2e.png)  

由于二叉查找树的特殊属性，如果要找到一个点的话只需要树的层数（log(N)）次；  
**联系上面的阵列，这样的话我们要找所有在UK工作的人，只需要找到UK这个节点，之后就可以获取节点中存储的这些人的行数，即只需要log(N)次查询**；  

但是如果我们需要查找一个范围内的数据，这就需要O(N)的时间复杂度了，因为你必须查找树的每一个节点，以判断它是否处于那 2 个值之间？  所以引出了B＋树；

###B+树索引

- 只有最底层的节点（叶子节点）才保存信息（相关表的行位置）
- 其它节点只是在搜索中用来指引到正确节点的。

![](http://jbcdn2.b0.upaiyun.com/2016/05/15c4b064af9ac7f357404a1b17ff1cae.png)


##哈希

![](http://ww1.sinaimg.cn/large/7cc829d3jw1f3drdsruaqj20hp09075r.jpg)





##查询优化器

所有的现代数据库都在用基于**成本的优化（即CBO）**来优化查询。

###索引
＊*索引都是已经排了序的。*

####全扫描

全扫描就是数据库完整的读一个表或索引。  
＊*就磁盘 I/O 而言，很明显全表扫描的成本比索引全扫描要高昂。*

####索引范围扫描
索引范围扫描是在进行类似“WHERE AGE > 20 AND AGE < 40 ”的查询时会出现的；当然，你需要在AGE字段上面添加索引才能用到索引范围扫描；

####唯一扫描

如果只需要从索引中取一个值你可以用唯一扫描；

####根据 ROW ID（行id） 存取

如：  

	SELECT LASTNAME, FIRSTNAME from PERSON WHERE AGE = 28
	
如果PERSION表的AGE有索引，那么优化器会使用索引找到所有age为28的人所在的行数，然后就会根据这些行数去找到这些人的数据，这是因为索引中只有 age 的信息而你要的是姓和名。  
但是如果：

	SELECT TYPE_PERSON.CATEGORY from PERSON ,TYPE_PERSON WHERE PERSON.AGE = TYPE_PERSON.AGE
	
这里的PERSON 表的索引会用来联接 TYPE_PERSON 表，但是 PERSON 表不会根据行ID 存取，因为你并没有要求这个表内的信息。

虽然这个方法在少量存取时表现很好，这个运算的真正问题其实是磁盘 I/O。假如需要大量的根据行ID存取，数据库也许会选择全扫描。



###联接

先假定外关系和内关系，A JOIN B 是 A 和 B 的联接，这里 A 是外关系，B 是内关系。而且假定外关系有N个元素，内关系有M个元素；  

A：外关系  **N**个元素  
B：内关系  **M**个元素

####嵌套循环联接

![](http://ww2.sinaimg.cn/mw690/7cc829d3jw1f3drdvtvlqj20er09njtc.jpg)

这个的时间复杂度是：O(N\*M)；  
在磁盘 I/O 方面， 针对 N 行外关系的每一行，内部循环需要从内关系读取 M 行。这个算法需要从磁盘读取 N+ N\*M 行。

####哈希联接

![](http://ww3.sinaimg.cn/large/7cc829d3jw1f3drdvx8ikj20jb0d0mzp.jpg)

